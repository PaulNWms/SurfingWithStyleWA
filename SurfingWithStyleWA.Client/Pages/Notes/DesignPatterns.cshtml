@page "/notes/design-patterns"

<h1>Design Patterns</h1>

<pre class="kaypro10">Links:
<a target="_blank" href="https://sourcemaking.com/design_patterns">Design patterns (and anti-patterns) site</a>
<a target="_blank" href="http://www.tutorialspoint.com/design_pattern">Design patterns in Java tutorial</a>

Abstract Factory
- A Factory represents a "family" of objects that it can create
- Everyday usage: DbProviderFactory is an abstract base class for SqlClientFactory
- Everyday usage: SqlClientFactory.CreateCommand() creates instances of DbCommand
- Creational

Adapter
- Resolves incompatible interfaces
- Everyday usage: Entity Framework
- Structural

Bridge
- Abstraction -> Abstraction -> Implementation
- Everyday usage: .NET provider model, e.g. IFormatProvider
- Structural

Builder
- Useful when you have a constructor with lots of parameters
- Example: Jimmy John's (order from a menu) vs. Subway (specify all the ingredients)
- Has a Director base class, which defines the assembly steps
- Has 2 or more Concrete Builder child classes, which actually create objects
- Similar to Template Method, but for constructors
- Creational

Chain of Responsibility
- Everyday usage: exception handling
- Message handling
- Behavioral

Command
- Represent an action as an object
- Everyday usage: ICommand (in MVVM or just generally)
- ICommand may include additional methods like Validate(), Undo(), Compensate(), etc.
- Behavioral

Composite (Tree)
- Treats leaves and branches the same (nodes)
- Everyday usage: Email can send to individuals or groups
- Structural

Decorator (wrapper)
- Attach additional responsibilities to an object (but use the same interface)
- Example: caching repository
- Even sealed classes can be wrapped
- Structural

Event Aggregator
- Subscibers subscribe only to the event aggregator instead of all the subscribers
- The event aggregator typically uses weak references to minimize memory leaks
- Use when: there are many publishers and subscribers

Façade
- Hides complexity
- Everyday usage: foreach
- Structural

Factory Method
- A base class or interface defines the creation method
- Subclasses implement the creation method in different ways 
- "Everyday" usage: IDbCommand.CreateParameter(), System.Windows.Forms.Control.CreateControlsInstance()
- Creational

Flyweight
- Instead of each instance containing all the data, shared objects are passed in
- Everyday usage: Graphics context in drawing, string interning
- Structural

Identity Map
- Everyday usage: Database table has a unique primary key

Interpreter
- The interpreter builds objects based on a grammar expressed in EBNF
- Related to composite pattern
- Example: a laser scanner interprets a UPC bar code
- Behavioral

Iterator
- Everyday usage: foreach and IEnumerable&lt;T&gt;
- MoveNext() and Current
- yield return
- Behavioral

Lazy Load

Mediator
- Behavioral

Memento
- Operations are placed on an Undo stack, undone operations are placed on a Redo stack
- The <em>originator</em> is the object whose state is being tracked.
- The <em>caretaker</em> performs operations on the originator.
- The <em>memento</em> holds the state of the originator.
- Use when: undo/redo
- Behavioral

MVP

MVVM

Null Object
- Provide a non-functional object in place of a null reference
- Often implemented as a static inner class of a base class

Observer
- Uses events to notify changes automatically
- Publish/Subscribe relationship
- Synchronous; the observable notifies the observers directly
- Risk of memory leaks, see Event Aggregator
- Everyday usage: Event Handlers
- Everyday usage: IObservable&lt;T&gt; and IObserver&lt;T&gt;
- Behavioral

Prototype
- Creational

Proxy
- Placeholder / Stand-in for actual object
- Everyday usage: SOAP Service Proxies
- Structural

Publish/Subscribe
- Uses events to notify changes explicitly
- Publish/Subscribe relationship
- Asynchronous, generally uses a message queue

Repository

Rules
- Separate the logic of each individual rule and its effects into its own class
- Separate the selection and processing of rules into a separate Evaluator class
- Use when you have a growing amount of conditional complexity
- Special case of the Command pattern
- Links:
  - <a target="_blank" href="http://thedailywtf.com/articles/soft_coding.aspx">Soft Coding</a>
  - <a target="_blank" href="http://www.jessrules.com/guidelines.shtml">Should You Use a Rules Engine?</a>
  - <a target="_blank" href="http://bit.ly/fDH8r">Simple .NET Rules Engine Discussion (StackOverflow)</a>
  - <a target="_blank" href="http://en.wikipedia.org/wiki/Business_rules_engine">Business Rules Engines</a>
  - <a target="_blank" href="http://bit.ly/aetfj0">Intro to WF Rules Engine</a>

Service Locator
- Identify a service through configuration
- Example: Domain Name Service, IoC container
- Createional

Simple Factory
- Decides which concrete type to return
- Everyday usage: System.Threading.Tasks.TaskFactory.Run() creates instances of Task
- Creational

Singleton
- Example: return (instance == null) ? new MyClass() : instance;
- Everyday usage: static
- Breaks Single Responsibility Principle
- Difficult to test
- Anti-pattern, better to use IoC container
- Creational

Specification

State
- Implement an FSM with state objects derived from a base class
- Use when: the behavior changes at runtime
- Code smell: switch statements based on state
- Behavioral

Strategy
- A class behavior or its algorithm can be changed at run time.
- Everyday usage: delegate parameter in method call
- Everyday usage: delegate parameter in constructor
- Behavioral

Template Method
- Base class defines the (sealed) template method, subclasses override steps
- Clients depend on base class
- Everyday usage: ASP.NET
- Use when:
  - 2 or more classes follow the same workflow
  - The workflow is invariant
  - Some workflow steps may be encapsulated in the base class
- Behavioral

Unit of Work
- Track changes in persistent objects and commit them in a batch
- Everyday usage: ADO.NET SqlDataAdapter, Entity Framework
  - Efficient data access
  - Reduces concurrency problems
  - Manages transactions

Visitor
- Puts all the logic for all of the classes in a single Visitor class
- Implement interface IBlah { void Accept(IVisitor visitor); } in each of the classes (double dispatch)
- Implement interface IVisitor, which has a method for each type to be visited
- Use when: looping over a collection of unrelated objects and performing an operation on each, without modifying them
- Behavioral
</pre>