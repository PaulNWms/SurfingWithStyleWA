@page "/notes/sql"

<h1>SQL</h1>

<pre class="kaypro10">Query steps:
1. Cartesian product (cross join)
2. apply the ON filter (join condition)
3. add outer rows
4. apply the WHERE filter
5. GROUP
6. apply CUBE or ROLLUP
7. apply the HAVING filter
8. process the SELECT list
9. apply the DISTINCT clause
10. apply the ORDER BY clause
11. apply the TOP operation

Three-valued logic in SQL means values can be TRUE, FALSE, or UNKNOWN (e.g. NULL > 0).  

UNKNOWN is treated as FALSE in ON, WHERE and HAVING filters.
UNKNOWN is treated as TRUE in in check constraints.

A GROUP BY clause groups all NULLs in one group.
An ORDER BY clause sorts all NULLs together.

You can't use aggregate filters in a WHERE condition because the data hasn't been grouped yet.

If a GROUP BY clause is specified in a query, all following steps (HAVING, SELECT) can specify only expressions that result in a scalar value for the group.

The only clause that can refer to column aliases defined in the SELECT list is ORDER BY.

Each step hands a logical "virtual tables" to the subsequent step until ORDER BY, which returns a cursor.

A query with an ORDER BY clause can therefore not be used as a table expression - view, inline table-valued function, subquery or CTE.

TOP is non-standard SQL and can use the cursor created by ORDER BY.  That is mainly how it is used.

UNION removes duplicate records, UNION ALL does not.

APPLY is similar to JOIN.  APPLY (logically) evaluates the left table, and then the right table is evaluated once for each row of the left table.
- CROSS APPLY only returns matching rows
- OUTER APPLY includes rows from the left table that didn't match (similar to LEFT OUTER JOIN)
- Use case: get the 2 most recent orders from each customer

PIVOT converts categorical data to columns.
UNPIVOT converts columns to categorical data.
</pre>