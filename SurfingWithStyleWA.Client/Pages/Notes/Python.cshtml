@page "/notes/python"

<h1>Python</h1>

<pre class="kaypro10">Links:
<a target="_blank" href="https://www.python.org/dev/peps/pep-0008/">PEP 8 -- Style Guide for Python Code</a>

Continue one line with '\'

Continue multiple lines with parenthetical expression '(...)' (preferred)

Separate multiple statements on one line with ';'

All variables are pointers (including ints)

Everything is an object (including ints)

# floor division
a // b

# exponentiation
a ** b

# bit SHIFT left, right
a << b; a >> b

# bitwise NOT
~a

# output binary
bin(10)

Boolean operators: and, or, not

# boolean XOR
(x > 1) != (x < 10)

# identity operators
a is b
a is not b

# membership operators
a in b
a not in b

# complex numbers
x = 1 + 2j

# null
x = None

# length of a string, list, tuple
len(s)

# string case
str.upper()
str.lower()
str.capitalize()
str.title()

# string, list concatenation
a + b

# string power
5 * s

# list
[1, 2, 3]

# tuple
(1, 2, 3)
1, 2, 3

# dict
{'a':1, 'b':2, 'c':3}

# set
{1, 2, 3}

# list append
x.append(11)

# list sort
x.sort()

# last element of list
x[-1]

# first 3 elements of list
x[0:3]
x[:3]

# last 3 elements of list
x[-3:len(x)]
x[-3:]

# select every other element of list
x[0:len(x):2]
x[::2]

# reverse list
x[::-1]

# slicing works on LHS of assignment
x[1:3] = [1, 2]

Tuples are immutable.

Indexing, slicing, and many other list functions work on tuples.

# set operations
primes | odds <=> primes.union(odds)
primes & odds <=> primes.intersection(odds)
primes - odds <=> primes.difference(odds)
primes ^ odds <=> primes.symmetric_difference(odds)

# other useful collections (there are still more)
collections.namedtuple  # Like a tuple, but each value has a name
collections.defaultdict # Like a dictionary, but unspecified keys have a user-specified default value
collections.OrderedDict # Like a dictionary, but the order of keys is maintained

if x == 0:
    print(x, "is zero")
elif x > 0:
    print(x, "is positive")
elif x < 0:
    print(x, "is negative")
else:
    print(x, "is unlike anything I've ever seen...")

for N in [2, 3, 5, 7]:
    print(N, end=' ') # print all on same line

for i in range(10):
    print(i, end=' ')

# range object
list(range(5, 10))
list(range(0, 10, 2))

i = 0
while i < 10:
    print(i, end=' ')
    i += 1

break

continue

# define functions with def
def f(val):
    return ('f', val)

Functions can have default arguments.

Functions can be called using named arguments.

# varargs - the significant things are the '*' and '**' modifiers
def catch_all(*args, **kwargs):
    print("args =", args)
    print("kwargs = ", kwargs)

# lambda statement - functions are objects too
add = lambda x, y: x + y
    add(1, 2)

# sort list of dict alphabetically by first name
sorted(data, key=lambda item: item['first'])

try:
    print("try something here")
except:
    print("this happens only if it fails")
else:
    print("this happens only if it succeeds")
finally:
    print("this happens no matter what")

raise RuntimeError("fail")

try:
    x = 1 / 0
except ZeroDivisionError as err:
    print("Error class is:  ", type(err))
    print("Error message is:", err)

# define a custom exception
class MySpecialError(ValueError):
    pass
raise MySpecialError("here's the message")

# zip
for lval, rval in zip(L, R):
    print(lval, rval)

# map
for val in map(square, range(10)):
    print(val, end=' ')

# filter
is_even = lambda x: x % 2 == 0
for val in filter(is_even, range(10)):
    print(val, end=' ')

# unzip
z = zip(L1, L2)
new_L1, new_L2 = zip(*z)

The itertools module contains permutation, combination and product functions.

# "ternary operator"
val if val >= 0 else -val

# list comprehensions - [<em>expr</em> for <em>var</em> in <em>iterable</em>]
[i for i in range(20) if i % 3 > 0]

# set comprehension
{n**2 for n in range(12)}

# dict comprehension
{n:n**2 for n in range(6)}

# generator expression
(n**2 for n in range(12))
</pre>
